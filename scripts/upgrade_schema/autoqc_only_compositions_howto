Suggested order of deployment:

    repoint rna_seqc rows from components with subset='all' to where subset in NULL;
    update schema, see scripts/upgrade_schema/upgrade_schema-autoqc2compositions;
    deploy new code;
    do not restart SeqQC servers! (new code searches via compositions, which are not linked yet);
    restart archival daemon;
    existing autoqc loader LSF jobs running from the old code: either wait to finish or reset to use the new code that will set the id_seq_composition fk value;
    back-fill id_seq_composition values in autoqc tables;
    optimize tables;
    restart SeqQC servers.

Tables to for update: adapter alignment_filter_metrics bam_flagstats contamination gc_bias gc_fraction genotype insert_size pulldown_metrics qx_yield ref_match sequence_error spatial_filter split_stats tag_decode_stats tag_metrics tags_reporters upstream_tags verify_bam_id.

Template for creating LSF jobs for back-filling in parallel:
cat scripts/upgrade_schema/upgrade_schema-autoqc2compositions | perl -ne 'my $line=q[];while (<>) {if ($_ =~ /==table/) {$_ =~ s/\s\Z//g;$line = $;} else {if ($line) {$ =~ s/\s\Z//g;if ($) {$line .= $;}else {print "${line}\n"; $line=q[];} } }}' | perl -nle 'my ($table_name) = $_ =~ /==table\ (\w+)/; print $table_name;my $command = qq[(echo "$_" | mysql --reconnect -h localhost -D xx -P 3306 -u user -pyy 2>&1 > ${table_name}.log) &]; print $command; system($command)'

Script for optimizing tables in parallel:
cat scripts/upgrade_schema/upgrade_schema-autoqc2compositions | grep 'OPTIMIZE TABLE' | perl -nle 'my$command=$_; my$table=$command; ($table) = $table =~ /(\w+);\Z/; $command = qq[(echo "$command" | mysql --reconnect -h ocalhost -D xx -P 3306 -u user -pyy 2>&1 > ${table}.log) &]; print $command; system($command);'

